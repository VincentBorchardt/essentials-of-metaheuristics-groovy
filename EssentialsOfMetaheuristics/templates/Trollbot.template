package evolved;

import robocode.*;
import robocode.util.Utils;
import java.awt.Color;
import java.util.Hashtable;
import java.util.Enumeration;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Point2D;
import java.util.Random;

//  HawkOnFire - a robot by rozu
//  With evolved evaluate() component by Nic McPhee

/*
 * This template has the following fields that need to be filled in:
 *   id : an id used in the generation of the name of the class.
 *   enemy_energy : the coefficient for the enemy's energy
 *   my_energy : the coefficient for our energy
 *   angle_diff : the coefficient for the different in angles between us and the point and then and the point
 *   distance : the coefficient for the distance between the point and the enemy
 */
 
public class Trollbot_${id} extends AdvancedRobot {
	static Hashtable<String, MicroEnemy> enemies = new Hashtable<String, MicroEnemy>();
	static MicroEnemy target;
	static Point2D.Double nextDestination;
	static Point2D.Double lastPosition;
	static Point2D.Double myPos;
	static double myEnergy;
	static double angleDelta = 1;
	static double angleCurrent = 0;
	static double changeDirChance = ${changeDirChance};
	static double optimalDistance = ${optimalDistance};
	static double rammingDistance = ${rammingDistance};
	static int recalculatePeriod = 15;
	static final Random random = new Random();
	
//- run -------------------------------------------------------------------------------------------------------------------------------------
	public void run() {
		// body, turret, radar
		setColors(Color.pink,Color.blue,Color.white);
		setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		
		setTurnRadarRightRadians(Double.POSITIVE_INFINITY);
		
		nextDestination = lastPosition = myPos = new Point2D.Double(getX(), getY());
		target = new MicroEnemy();
		
		do {
			
			myPos = new Point2D.Double(getX(),getY());
			myEnergy = getEnergy();
			
			// wait until you have scanned all other bots. this should take around 7 to 9 ticks.
			if(target.live) {// && getTime()>9) {
				doMovementAndGun();
			}
			execute();
			
		} while(true);
	}
	
//- stuff -----------------------------------------------------------------------------------------------------------------------------------
	public void doMovementAndGun() {
		double distanceToTarget = myPos.distance(target.pos);
		double distanceToPredictedTarget = myPos.distance(target.predictedLocation);
		
	//**** gun ******************//

		if(Math.abs(getGunTurnRemaining()) == 0 && myEnergy > 1 && distanceToPredictedTarget <= 1200) {
			//setFire(getBulletPower(myEnergy, distanceToTarget, target.energy));
		}

		Point2D.Double newTarget = new Point2D.Double(target.predictedLocation.x, target.predictedLocation.y);
		setTurnGunRightRadians(Utils.normalRelativeAngle(calcAngle(newTarget, myPos) - getGunHeadingRadians()));
		
	//**** move *****************//
		if (getTime() % recalculatePeriod == 0) {
			double deviation;
			if (distanceToTarget < rammingDistance) {
				deviation = 0;
			} else if (distanceToTarget < optimalDistance) {
				deviation = Math.PI + ((distanceToTarget - rammingDistance)*(-Math.PI/2) / (optimalDistance-rammingDistance));
			} else {
				deviation = (Math.PI/2) + ((distanceToTarget)*(-Math.PI/2) / (1200 - optimalDistance));
			}// what if there is no target?
			if (myPos.x < 50 || myPos.y < 50 || getBattleFieldWidth() - myPos.x < 50 || getBattleFieldHeight() - myPos.y < 50) {
				angleDelta *= -1;
			} else if (random.nextFloat() <= changeDirChance) {
				angleDelta *= -1;
			}
			deviation *= angleDelta;
			double angle = (calcAngle(target.pos, myPos) + deviation) - getHeadingRadians();
			double direction = 1;
			if(Math.cos(angle) < 0) {
				angle += Math.PI;
				direction = -1;
			}
			setTurnRightRadians(angle = Utils.normalRelativeAngle(angle));
			setAhead(8 * direction * recalculatePeriod);
			//setMaxVelocity(Math.abs(angle) > 1 ? 0 : 8d);
		}
	}
	
//- eval position ---------------------------------------------------------------------------------------------------------------------------
	public static double evaluate(Point2D.Double p, double addLast) {
		// this is basically here that the bot uses more space on the battlefield. In melee it is dangerous to stay somewhere too long.
		double eval = addLast*0.08/p.distanceSq(lastPosition);
		
		Enumeration<MicroEnemy> enemy_enum = enemies.elements();
		while (enemy_enum.hasMoreElements()) {
			MicroEnemy en = enemy_enum.nextElement();
			// this is the heart of HawkOnFire. So I try to explain what I wanted to do:
			// -	Math.min(en.energy/myEnergy,2) is multiplied because en.energy/myEnergy is an indicator how dangerous an enemy is
			// -	Math.abs(Math.cos(calcAngle(myPos, p) - calcAngle(en.pos, p))) is bigger if the moving direction isn't good in relation
			//		to a certain bot. it would be more natural to use Math.abs(Math.cos(calcAngle(p, myPos) - calcAngle(en.pos, myPos)))
			//		but this wasn't going to give me good results
			// -	1 / p.distanceSq(en.pos) is just the normal anti gravity thing
			if(en.live) {
				eval += en.energy;
				eval += myEnergy;
				eval += (calcAngle(myPos, p) - calcAngle(en.pos, p));
				eval += p.distanceSq(en.pos);
			}
		}
		return eval;
	}
	
	public double getBulletPower(double uE, double tD, double tE) {
		return Math.min(Math.min(uE/6d, 1300d/tD), tE/3d);
	}
	
	public double getBulletPower(ScannedRobotEvent e) {
		double uE, tD, tE;
		
		uE = getEnergy();
		tD = e.getDistance();
		tE = e.getEnergy();
		
		return getBulletPower(uE, tD, tE);
	}
	
	public double getPredictiveHeading(ScannedRobotEvent e) {
		double vB = 20 - 3 * getBulletPower(e);
		double xT, yT, vT, bT, xU, yU, vU, bU, tF, bB;

		xU = getX();
		yU = getY();
		//vU = getVelocity();
		vU = 0;
		bU = -getHeadingRadians()+Math.PI/2;

		bT = -e.getHeadingRadians()+Math.PI/2;
		xT = getX()+Math.sin(e.getBearingRadians())*e.getDistance();
		yT = getY()+Math.cos(e.getBearingRadians())*e.getDistance();
		vT = e.getVelocity();

		/* Assumes speed of bullet adds with speed of robot */
		tF =
			(
				vT*xT*Math.cos(bT)-
				vT*xU*Math.cos(bT)-
				vU*xT*Math.cos(bU)+
				vU*xU*Math.cos(bU)+
				vT*yT*Math.sin(bT)-
				vT*yU*Math.sin(bT)-
				vU*yT*Math.sin(bU)+
				vU*yU*Math.sin(bU)+
				Math.sqrt(
					(
						Math.pow(xT,2)-
						2*xT*xU+
						Math.pow(xU,2)+
						Math.pow(yT-yU,2)
					)*
					(
						Math.pow(vB,2)-
						Math.pow(vT,2)-
						Math.pow(vU,2)+
						2*vT*vU*Math.cos(bT-bU)
					)+
					Math.pow(
						vT*(xT-xU)*Math.cos(bT)-
							vU*(xT-xU)*Math.cos(bU)+
							(yT-yU)*(vT*Math.sin(bT)-vU*Math.sin(bU)),
						2
					)
				)
			) /
			(
				Math.pow(vB,2)-
				Math.pow(vT,2)-
				Math.pow(vU,2)+
				2*vT*vU*Math.cos(bT-bU)
			);

		bB = 
			Math.atan2(
				yT+tF*vT*Math.sin(bT)-
					(yU+tF*vU*Math.sin(bU)),
				xT+tF*vT*Math.cos(bT)-
					(xU+tF*vU*Math.cos(bU))
			);
		bB = -bB + Math.PI/2;
		
		return bB;
	}
	
//- scan event ------------------------------------------------------------------------------------------------------------------------------
	public void onScannedRobot(ScannedRobotEvent e)
	{
		MicroEnemy en = enemies.get(e.getName());
		double bB = getPredictiveHeading(e);

		if(en == null){
			en = new MicroEnemy();
			enemies.put(e.getName(), en);
		}
		
		en.energy = e.getEnergy();
		en.live = true;
		en.pos = calcPoint(myPos, e.getDistance(), getHeadingRadians() + e.getBearingRadians());
		en.predictedLocation = calcPoint(myPos, e.getDistance(), getHeadingRadians() + bB);
		
		// normal target selection: the one closer to you is the most dangerous so attack him
		if(!target.live || e.getDistance() < myPos.distance(target.pos)) {
			target = en;
		}
		
		// locks the radar if there is only one opponent left
		if(getOthers()==1)	setTurnRadarLeftRadians(getRadarTurnRemainingRadians());
	}
	
//- minor events ----------------------------------------------------------------------------------------------------------------------------
	public void onRobotDeath(RobotDeathEvent e) {
		enemies.get(e.getName()).live = false;
	}
	
//- math ------------------------------------------------------------------------------------------------------------------------------------
	private static Point2D.Double calcPoint(Point2D.Double p, double dist, double ang) {
		return new Point2D.Double(p.x + dist*Math.sin(ang), p.y + dist*Math.cos(ang));
	}
	
	private static double calcAngle(Point2D.Double p2,Point2D.Double p1){
		return Math.atan2(p2.x - p1.x, p2.y - p1.y);
	}
//- microEnemy ------------------------------------------------------------------------------------------------------------------------------
	public class MicroEnemy {
		public Point2D.Double pos;
		public double energy;
		public boolean live;
		public Point2D.Double predictedLocation;
	}
}